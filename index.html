<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Truck ETA Calculator v1.1</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Flatpickr CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { background-color: #f4f4f4; }
    .calculator {
      background: #fff; padding: 20px; border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-top: 20px;
    }
    #result { white-space: pre-line; }
    .floating-lang-btn {
      position: fixed; top: 15%; left: 0; z-index: 1050;
    }
    .badge-dot {
      display:inline-block; width:10px; height:10px; border-radius:50%;
      margin-right:6px; background:#0d6efd;
    }
    nav { background:#fff; box-shadow:0 0 5px rgba(0,0,0,0.1); }
    .app-section { display:none; }
    #contactsSection { font-family: Arial, sans-serif; margin: 2em; }
    #contactsSection h1 { color:#333; }
    #contactsSection input[type="file"] { margin: 1em 0; }
    #contactsSection button { padding: 0.5em 1em; margin-top: 1em; cursor: pointer; }
    #contactsSection #download { display: none; margin-top: 1em; text-decoration: none; background: #4CAF50; color: white; padding: 0.5em 1em; border-radius: 5px; }
  </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container-fluid">
    <a class="navbar-brand" href="#" onclick="showSection('etaSection')">Truck Tools</a>
    <div class="navbar-nav">
      <a class="nav-link" href="#" onclick="showSection('etaSection')">ETA Calc</a>
      <a class="nav-link" href="#" onclick="showSection('contactsSection')">Contacts Converter</a>
      <a class="nav-link" href="#" onclick="showSection('kmSection')">Week Data</a>
    </div>
  </div>
</nav>

<section id="etaSection" class="app-section">
<!-- Floating Language Selector Button -->
<button class="btn btn-secondary btn-sm floating-lang-btn" data-bs-toggle="offcanvas" data-bs-target="#offcanvasLanguage" aria-controls="offcanvasLanguage">
  US
</button>

<!-- Offcanvas Sidebar for Language Selection -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasLanguage" aria-labelledby="offcanvasLabel">
  <div class="offcanvas-header">
    <h5 id="offcanvasLabel">Select Language</h5>
    <button type="button" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="offcanvas-body">
    <select id="languageSelect" class="form-select" onchange="updateLocalization()">
      <option value="en">English</option>
      <option value="lt">Lietuvių</option>
      <option value="ru">Русский</option>
    </select>
  </div>
</div>

<div class="container">
  <div class="calculator">
    <div class="d-flex align-items-center justify-content-between">
      <h2 id="calcTitle" class="mb-4">Truck ETA Calculator v1.1 (Interactive Delay Adjustment)</h2>
      <span class="text-muted">v1.1</span>
    </div>

    <!-- Controls row -->
    <div class="row g-3">
      <div class="col-md-4">
        <label for="startTime" class="form-label" id="startTimeLabel">Start Time:</label>
        <input type="text" id="startTime" class="form-control">
      </div>

      <div class="col-md-4">
        <p id="drivingConfigLabel" class="fw-bold mb-1">Driving Configuration:</p>
        <div class="form-check">
          <input type="radio" class="form-check-input" id="single" name="driverType" value="single" checked>
          <label for="single" class="form-check-label" id="singleDriverLabel">Single Driver (9h available per segment)</label>
        </div>
        <div class="form-check">
          <input type="radio" class="form-check-input" id="two" name="driverType" value="two">
          <label for="two" class="form-check-label" id="twoDriversLabel">Two Drivers (18h available per segment)</label>
        </div>
      </div>

      <div class="col-md-4">
        <label for="customHours" class="form-label" id="customHoursLabel">Custom remaining driving time for first segment (optional):</label>
        <input type="number" id="customHours" placeholder="e.g., 6" step="0.1" class="form-control">
      </div>

      <div class="col-md-4">
        <label for="distance" class="form-label" id="distanceLabel">Distance to Drive (km):</label>
        <input type="number" id="distance" step="0.1" class="form-control">
      </div>

      <div class="col-md-4">
        <label for="speed" class="form-label" id="speedLabel">Average Speed (km/h):</label>
        <input type="number" id="speed" step="0.1" class="form-control">
      </div>

      <!-- Refuelings input -->
      <div class="col-md-4">
        <label for="refuels" class="form-label" id="refuelsLabel">Number of Refuelings (each 1h delay):</label>
        <input type="number" id="refuels" min="0" max="10" value="0" class="form-control">
      </div>

      <!-- Ferry time -->
      <div class="col-md-4">
        <label for="ferryTime" class="form-label" id="ferryTimeLabel">Total Ferry Time (minutes delay):</label>
        <input type="number" id="ferryTime" min="0" value="0" class="form-control">
      </div>

      <!-- Options -->
      <div class="col-md-8">
        <div class="card">
          <div class="card-body">
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="autoFerryRestToggle" checked>
              <label class="form-check-label" for="autoFerryRestToggle" id="autoFerryRestLabel">
                Auto-convert any ferry ≥ 6h into a daily rest
              </label>
            </div>
            <div class="small text-muted" id="dutyRuleNote">
              Delays are off-duty by default; they will count inside duty as needed to keep daily spread ≤ 15h (single) or 21h (two).
            </div>
            <div class="mt-2">
              <span class="badge-dot"></span>
              <span id="reducedRestsInfo">Reduced (9h) daily rests used this week: <strong id="reducedCount">0</strong>/2</span>
              <button id="resetWeekBtn" class="btn btn-sm btn-outline-secondary ms-2">Reset week counter</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Break override and reduced rest inputs -->
      <div class="col-md-6">
        <label for="breakOverrides" class="form-label" id="breakOverridesLabel">In-shift break overrides (segment:minutes):</label>
        <input type="text" id="breakOverrides" class="form-control" placeholder="e.g., 2:60,3:45">
      </div>
      <div class="col-md-6">
        <label for="reducedRests" class="form-label" id="reducedRestsLabel">Reduced daily rests (numbers):</label>
        <input type="text" id="reducedRests" class="form-control" placeholder="e.g., 1,3">
      </div>

      <!-- Ferry assignment container (shown only if ferry > 0) -->
      <div class="col-12" id="ferryAssignmentContainer" style="display:none;">
        <div class="card mt-2">
          <div class="card-body">
            <h5 id="ferryDelayAssignmentHeader" class="mb-3">Ferry Delay Assignment</h5>
            <label for="ferrySegment" class="form-label" id="ferrySegmentLabel">Apply Ferry Delay in segment (number):</label>
            <input type="number" id="ferrySegment" min="1" value="1" class="form-control" style="max-width:200px;">
          </div>
        </div>
      </div>

      <!-- Refuel assignment container -->
      <div class="col-12">
        <div class="card mt-2">
          <div class="card-body">
            <div id="refuelAssignmentsContainer"></div>
          </div>
        </div>
      </div>

    </div><!-- /row -->

    <!-- Calculate button -->
    <div class="mt-4">
      <button id="calcTripButton" onclick="calculateTripAndDisplay()" class="btn btn-primary">Calculate Trip</button>
    </div>

    <!-- Trip Breakdown & Results -->
    <div class="accordion mt-4" id="tripBreakdownAccordion">
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingBreakdown">
          <button id="tripBreakdownAccordionButton" class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseBreakdown" aria-expanded="false" aria-controls="collapseBreakdown">
            Trip Breakdown & Results
          </button>
        </h2>
        <div id="collapseBreakdown" class="accordion-collapse collapse" aria-labelledby="headingBreakdown" data-bs-parent="#tripBreakdownAccordion">
          <div class="accordion-body" id="result"><!-- results injected here --></div>
        </div>
      </div>
    </div>

  </div>
</div>
</section>

<section id="contactsSection" class="app-section">
  <h1>CSV Contact Converter</h1>
  <input type="file" id="csvInput" accept=".csv" />
  <br>
  <button onclick="convertCSV()">Convert</button>
  <br>
  <a id="download" href="#" download="converted_contacts.csv">Download Converted CSV</a>
</section>

<section id="kmSection" class="app-section">
  <div class="container mt-4">
    <h2>Upload Your data (57).xlsx</h2>
    <input type="file" id="inputFile" accept=".xlsx, .xls">
    <button onclick="processFile()" class="btn btn-primary ms-2">Process File</button>
  </div>
</section>

<!-- Bootstrap Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<!-- Flatpickr -->
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
  // ====== APP STATE (v1.1) ======
  class AppState {
    constructor() {
      this.settings = {
        dutyCapHours: { single: 15, two: 21 },   // daily spread caps
        delayMode: "auto",                       // off-duty by default; pull in as needed
        autoFerryRest: true,                     // default ON (toggle in UI)
        autoFerryRestThreshold: 6,               // hours
        preferReducedRestFirst: true             // prefer 9h before 11h
      };
      this.weeklyCounters = {
        reducedRestsUsed: 0                      // Weekly counter for 9h reduced daily rests
      };
    }

    incrementReducedRest() {
      this.weeklyCounters.reducedRestsUsed++;
      return this.weeklyCounters.reducedRestsUsed;
    }

    resetWeeklyCounters() {
      this.weeklyCounters.reducedRestsUsed = 0;
    }
  }
  const APP_STATE = new AppState();

  // ====== I18N ======
  var translations = {
    "en": {
      "title": "Truck ETA Calculator v1.1 (Interactive Delay Adjustment)",
      "drivingConfiguration": "Driving Configuration:",
      "singleDriver": "Single Driver (9h available per segment)",
      "twoDrivers": "Two Drivers (18h available per segment)",
      "customHours": "Custom remaining driving time for first segment (optional):",
      "distance": "Distance to Drive (km):",
      "speed": "Average Speed (km/h):",
      "refuels": "Number of Refuelings (each 1h delay):",
      "ferryTime": "Total Ferry Time (minutes delay):",
      "breakOverrides": "In-shift break overrides (segment:minutes):",
      "breakOverridesPlaceholder": "e.g., 2:60,3:45",
      "reducedRests": "Reduced daily rests (numbers):",
      "reducedRestsPlaceholder": "e.g., 1,3",
      "calculateTrip": "Calculate Trip",
      "ferryDelayAssignment": "Ferry Delay Assignment",
      "applyFerryDelayInSegment": "Apply Ferry Delay in segment (number):",
      "tripBreakdownResults": "Trip Breakdown & Results",
      "finalEstimatedArrival": "Final Estimated Arrival Time (with delays):",
      "totalTripDuration": "Total Trip Duration (with delays):",
      "tripBreakdown": "Trip Breakdown:",
      "destinationReached": "Arrival:",
      "autoFerryRestLabel": "Auto-convert any ferry ≥ 6h into a daily rest",
      "dutyRuleNote": "Delays are off-duty by default; they will count inside duty as needed to keep daily spread ≤ 15h (single) or 21h (two).",
      "reducedInfo": "Reduced (9h) daily rests used this week:",
      "noRefuels": "No refuel delays specified."
    },
    "lt": {
      "title": "Sunkvežimio atvykimo laiko skaičiuoklė v1.1 (interaktyvus vėlavimų koregavimas)",
      "drivingConfiguration": "Vairavimo konfigūracija:",
      "singleDriver": "Vairuotojas vienas (9 val. per segmentą)",
      "twoDrivers": "Du vairuotojai (18 val. per segmentą)",
      "customHours": "Pirmojo segmento likęs vairavimo laikas (nebūtina):",
      "distance": "Važiavimo atstumas (km):",
      "speed": "Vidutinis greitis (km/h):",
      "refuels": "Degalų papildymų skaičius (kiekvienas – 1 val. vėlavimas):",
      "ferryTime": "Kelto laikas (vėlavimas min.):",
      "breakOverrides": "Pertraukų keitimas (segmentas:min):",
      "breakOverridesPlaceholder": "pvz., 2:60,3:45",
      "reducedRests": "Sumažinti dienos poilsiai (numeriai):",
      "reducedRestsPlaceholder": "pvz., 1,3",
      "calculateTrip": "Apskaičiuoti kelionę",
      "ferryDelayAssignment": "Kelto vėlavimo priskyrimas",
      "applyFerryDelayInSegment": "Priskirti kelto laiką segmentui (numeris):",
      "tripBreakdownResults": "Kelionės apžvalga ir rezultatai",
      "finalEstimatedArrival": "Numatomas atvykimo laikas (su vėlavimais):",
      "totalTripDuration": "Bendra kelionės trukmė (su vėlavimais):",
      "tripBreakdown": "Kelionės apžvalga:",
      "destinationReached": "Atvykimas:",
      "autoFerryRestLabel": "Automatiškai paversti ≥ 6 val. keltą dienos poilsiu",
      "dutyRuleNote": "Vėlavimai pagal nutylėjimą neskaičiuojami kaip darbo laikas; prireikus bus įtraukti, kad dienos trukmė neviršytų 15 val. (vienas) ar 21 val. (du).",
      "reducedInfo": "Sumažintų (9 val.) dienos poilsių šią savaitę:",
      "noRefuels": "Degalų papildymų nenurodyta."
    },
    "ru": {
      "title": "Калькулятор ETA грузовика v1.1 (интерактивная корректировка задержек)",
      "drivingConfiguration": "Конфигурация вождения:",
      "singleDriver": "Один водитель (9 ч на сегмент)",
      "twoDrivers": "Два водителя (18 ч на сегмент)",
      "customHours": "Оставшееся время вождения для первого сегмента (необязательно):",
      "distance": "Расстояние (км):",
      "speed": "Средняя скорость (км/ч):",
      "refuels": "Количество заправок (каждая — задержка 1 ч):",
      "ferryTime": "Время парома (задержка, мин):",
      "breakOverrides": "Изменения перерывов (сегмент:мин):",
      "breakOverridesPlaceholder": "напр., 2:60,3:45",
      "reducedRests": "Сокращённые ежедневные отдыхи (номера):",
      "reducedRestsPlaceholder": "напр., 1,3",
      "calculateTrip": "Рассчитать поездку",
      "ferryDelayAssignment": "Назначение задержки парома",
      "applyFerryDelayInSegment": "Применить задержку парома к сегменту (номер):",
      "tripBreakdownResults": "Разбивка поездки и результаты",
      "finalEstimatedArrival": "Предполагаемое время прибытия (с задержками):",
      "totalTripDuration": "Общая длительность поездки (с задержками):",
      "tripBreakdown": "Разбивка поездки:",
      "destinationReached": "Прибытие:",
      "autoFerryRestLabel": "Автоматически превращать паром ≥ 6 ч в ежедневный отдых",
      "dutyRuleNote": "Задержки по умолчанию вне рабочего времени; при необходимости будут учтены как рабочее, чтобы держать пределы 15 ч (один) / 21 ч (два).",
      "reducedInfo": "Сокращённые (9 ч) ежедневные отдыхи на этой неделе:",
      "noRefuels": "Заправки не указаны."
    }
  };
  var currentLang = "en";

  // ====== GLOBALS ======
  let startTimeObj = null; // Safari-safe: captured from Flatpickr onChange

  // ====== UTILITIES ======
  function formatTime(date) {
    let h = date.getHours();
    let m = date.getMinutes();
    if (h < 10) h = '0' + h;
    if (m < 10) m = '0' + m;
    return h + ':' + m;
  }
  function formatDateTime(date) {
    const y = date.getFullYear();
    let mo = date.getMonth() + 1, d = date.getDate();
    if (mo < 10) mo = '0' + mo;
    if (d < 10) d = '0' + d;
    return y + '-' + mo + '-' + d + ' ' + formatTime(date);
  }
  function formatH(h) {
    const total = Math.round(h * 60);
    const hh = Math.floor(total / 60);
    const mm = total % 60;
    return `${hh}h ${mm.toString().padStart(2, "0")}m`;
  }

  // ====== INIT PICKER (Safari-safe) ======
  flatpickr("#startTime", {
    enableTime: true,
    dateFormat: "Y-m-d H:i",
    time_24hr: true,
    onChange: (selectedDates) => { startTimeObj = selectedDates[0] || null; }
  });

  // ====== I18N APPLY ======
  function updateLocalization() {
    currentLang = document.getElementById("languageSelect").value;
    const t = translations[currentLang];

    document.getElementById("calcTitle").innerText = t["title"];
    document.getElementById("drivingConfigLabel").innerText = t["drivingConfiguration"];
    document.getElementById("singleDriverLabel").innerText = t["singleDriver"];
    document.getElementById("twoDriversLabel").innerText = t["twoDrivers"];
    document.getElementById("customHoursLabel").innerText = t["customHours"];
    document.getElementById("distanceLabel").innerText = t["distance"];
    document.getElementById("speedLabel").innerText = t["speed"];
    document.getElementById("refuelsLabel").innerText = t["refuels"];
    document.getElementById("ferryTimeLabel").innerText = t["ferryTime"];
    document.getElementById("breakOverridesLabel").innerText = t["breakOverrides"];
    document.getElementById("breakOverrides").placeholder = t["breakOverridesPlaceholder"];
    document.getElementById("reducedRestsLabel").innerText = t["reducedRests"];
    document.getElementById("reducedRests").placeholder = t["reducedRestsPlaceholder"];
    document.getElementById("calcTripButton").innerText = t["calculateTrip"];
    document.getElementById("ferryDelayAssignmentHeader").innerText = t["ferryDelayAssignment"];
    document.getElementById("ferrySegmentLabel").innerText = t["applyFerryDelayInSegment"];
    document.getElementById("tripBreakdownAccordionButton").innerText = t["tripBreakdownResults"];
    document.getElementById("autoFerryRestLabel").innerText = t["autoFerryRestLabel"];
    document.getElementById("dutyRuleNote").innerText = t["dutyRuleNote"];
    document.getElementById("reducedRestsInfo").innerHTML =
      `${t["reducedInfo"]} <strong id="reducedCount">${APP_STATE.weeklyCounters.reducedRestsUsed}</strong>/2`;

    // Floating button text
    var langButton = document.querySelector(".floating-lang-btn");
    langButton.textContent = currentLang === "en" ? "US" : (currentLang === "lt" ? "LT" : "RU");

    // regenerate refuel assignment text
    generateRefuelAssignments();
  }

  // ====== EVENT WIRING ======
  window.onload = function() {
    updateLocalization();
    updateFerryAssignmentVisibility();
    document.getElementById('reducedCount').innerText = APP_STATE.weeklyCounters.reducedRestsUsed;
    document.getElementById('autoFerryRestToggle').checked = APP_STATE.settings.autoFerryRest;
  };

  document.getElementById('ferryTime').addEventListener('input', updateFerryAssignmentVisibility);
  document.getElementById('refuels').addEventListener('input', function() {
    let v = parseInt(this.value) || 0; if (v > 10) this.value = 10;
    generateRefuelAssignments();
  });

  document.querySelectorAll('input[name="driverType"]').forEach(r => {
    r.addEventListener('change', () => {/* nothing extra needed; calculation uses it directly */});
  });

  document.getElementById('distance').addEventListener('input', ()=>{});
  document.getElementById('speed').addEventListener('input', ()=>{});
  document.getElementById('customHours').addEventListener('input', ()=>{});

  document.getElementById('resetWeekBtn').addEventListener('click', () => {
    APP_STATE.resetWeeklyCounters();
    document.getElementById('reducedCount').innerText = APP_STATE.weeklyCounters.reducedRestsUsed;
    updateLocalization();
  });

  document.getElementById('autoFerryRestToggle').addEventListener('change', (e) => {
    APP_STATE.settings.autoFerryRest = e.target.checked;
  });

  // ====== UI HELPERS ======
  function updateFerryAssignmentVisibility() {
    var ferryTimeValue = parseFloat(document.getElementById('ferryTime').value) || 0;
    var c = document.getElementById('ferryAssignmentContainer');
    c.style.display = ferryTimeValue > 0 ? "block" : "none";
  }

  function generateRefuelAssignments() {
    const t = translations[currentLang];
    let refuelCount = parseInt(document.getElementById('refuels').value) || 0;
    let container = document.getElementById('refuelAssignmentsContainer');
    container.innerHTML = "";
    if (refuelCount > 0) {
      container.innerHTML += `<h5>${t["refuelDelayAssignments"] || "Refuel Delay Assignments"}</h5>`;
      for (let i = 0; i < refuelCount; i++) {
        const row = document.createElement('div');
        row.className = 'd-flex align-items-center mb-2';
        row.innerHTML = `
          <div class="me-2">${(t["refuelEvent"] || "Refuel event ")}${i+1}${(t["segment"] || " segment: ")}</div>
          <input type="number" class="refuelAssignment form-control" min="1" value="1" style="max-width:120px;">
        `;
        container.appendChild(row);
      }
    } else {
      container.innerHTML = `<p class="mb-0">${t["noRefuels"]}</p>`;
    }
  }

  function parseBreakOverrides(str) {
    const result = {};
    if (!str) return result;
    str.split(',').forEach(part => {
      const [seg, mins] = part.split(':').map(s => s.trim());
      const sNum = parseInt(seg, 10);
      const mNum = parseFloat(mins);
      if (!isNaN(sNum) && !isNaN(mNum)) {
        result[sNum] = mNum / 60;
      }
    });
    return result;
    }

  function parseReducedRests(str) {
    if (!str) return [];
    return str.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n));
  }

  // ====== CORE CALC (v1.1) ======
  function calculateTripWithDelays(
    appState,
    baseTime,                    // hours to drive (distance / speed)
    defaultAvailableTime,        // 9 or 18
    firstSegmentAvailableTime,
    driverType,                  // "single" | "two"
    speed,                       // km/h
    startTime,                   // Date
    refuelEvents,                // [{segment, delay:1.0}, ...]
    ferryEvent,                  // {segment, delay:hours}
    breakOverrides = {},
    reducedRestIndices = []
  ) {
    const breakdown = [];
    const segments = [];

    const isSingle = (driverType === "single");
    const dutyCap = isSingle ? appState.settings.dutyCapHours.single : appState.settings.dutyCapHours.two;

    let currentTime = new Date(startTime.getTime());
    let remainingDrive = baseTime;
    let segmentIndex = 0;

    // Duty since last DAILY REST
    let dutyUsed = 0;

    // Warnings
    let warnings = [];

    const reducedSet = new Set(reducedRestIndices);
    let restCounter = 0;
    function pickDailyRest() {
      restCounter++;
      if (isSingle) {
        let useReduced = false;
        if (reducedSet.has(restCounter)) {
          useReduced = true;
        } else if (appState.settings.preferReducedRestFirst && appState.weeklyCounters.reducedRestsUsed < 2) {
          useReduced = true;
        }
        if (useReduced) {
          appState.incrementReducedRest();
          const reducedEl = document.getElementById('reducedCount');
          if (reducedEl) reducedEl.innerText = appState.weeklyCounters.reducedRestsUsed;
          if (appState.weeklyCounters.reducedRestsUsed > 2) {
            warnings.push("More than two 9h reduced daily rests used this week.");
          }
          return 9;
        }
      }
      return 11;
    }

    function getDelaysForSegment(segIdx) {
      let extraDelay = 0;
      let delayNotes = [];

      if (refuelEvents && refuelEvents.length) {
        refuelEvents.forEach(e => {
          if (e.segment === segIdx) {
            extraDelay += e.delay;
            delayNotes.push(`refuel ${e.delay.toFixed(2)}h`);
          }
        });
      }

      let ferryDelay = 0, ferryNote = "";
      let ferryAsRest = false;
      if (ferryEvent && ferryEvent.delay > 0 && ferryEvent.segment === segIdx) {
        ferryDelay = ferryEvent.delay;
        ferryNote = `ferry ${ferryDelay.toFixed(2)}h`;
        if (appState.settings.autoFerryRest && ferryDelay >= appState.settings.autoFerryRestThreshold) {
          ferryAsRest = true;
        }
      }
      extraDelay += ferryDelay;
      if (ferryNote) delayNotes.push(ferryNote);

      return { extraDelay, delayNotes, ferryAsRest, ferryDelay };
    }

    while (remainingDrive > 0) {
      segmentIndex++;
      const segmentAvail = (segmentIndex === 1 ? firstSegmentAvailableTime : defaultAvailableTime);

      const { extraDelay, delayNotes, ferryAsRest } = getDelaysForSegment(segmentIndex);

      let plannedDrive = Math.min(segmentAvail, remainingDrive);
      let inShiftBreak = (isSingle && plannedDrive > 4.5) ? 0.75 : 0;
      if (breakOverrides[segmentIndex] !== undefined) {
        inShiftBreak = breakOverrides[segmentIndex];
      }

      // AUTO delay behavior
      let countedDelay = extraDelay;
      let offDutyDelay = 0;

      if (appState.settings.delayMode === "auto" && !ferryAsRest) {
        countedDelay = 0; // try keeping all delay off-duty
        let wouldBe = dutyUsed + plannedDrive + inShiftBreak;
        if (wouldBe > dutyCap) {
          // Trim driving to respect cap
          const overflow = wouldBe - dutyCap;
          plannedDrive = Math.max(0, plannedDrive - overflow);
          inShiftBreak = (isSingle && plannedDrive > 4.5) ? 0.75 : (plannedDrive > 0 ? 0 : 0);
        } else {
          // Pull just enough delay into duty, rest off-duty
          const room = dutyCap - (dutyUsed + plannedDrive + inShiftBreak);
          countedDelay = Math.min(extraDelay, room);
          offDutyDelay = extraDelay - countedDelay;
        }
      }

      // Two drivers: ensure we never exceed per-segment available after counted delay
      if (!isSingle) {
        const effectiveAvail = Math.max(0, segmentAvail - countedDelay);
        plannedDrive = Math.min(plannedDrive, effectiveAvail, remainingDrive);
      }

      const segmentDuty = plannedDrive + inShiftBreak + countedDelay;

      // Delay-only segment (no driving)
      if (plannedDrive === 0 && (countedDelay > 0 || offDutyDelay > 0)) {
        const startAt = new Date(currentTime);
        if (countedDelay > 0) {
          dutyUsed += countedDelay;
          currentTime = new Date(currentTime.getTime() + countedDelay * 3600000);
        }
        if (offDutyDelay > 0) {
          currentTime = new Date(currentTime.getTime() + offDutyDelay * 3600000);
        }
        const delayText = delayNotes.length ? ` (Extra: ${delayNotes.join(", ")})` : "";
        breakdown.push(
          `Segment ${segmentIndex}:\nStart at ${formatTime(startAt)}.\nDelay-only${delayText}\nEnd at ${formatTime(currentTime)}.`
        );
        if (ferryAsRest) {
          const restLen = pickDailyRest();
          const rs = new Date(currentTime);
          const re = new Date(currentTime.getTime() + restLen * 3600000);
          breakdown.push(`Daily rest (ferry as rest): ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
          currentTime = re;
          dutyUsed = 0;
        }
        continue;
      }

      // Normal driving segment
      const segmentStart = new Date(currentTime);
      const distanceCovered = plannedDrive * speed;

      // Advance time for driving + in-shift + counted delay
      currentTime = new Date(currentTime.getTime() + segmentDuty * 3600000);
      dutyUsed += plannedDrive + inShiftBreak + countedDelay;

      if (offDutyDelay > 0) {
        const waitStart = new Date(currentTime);
        currentTime = new Date(currentTime.getTime() + offDutyDelay * 3600000);
        breakdown.push(`Off-duty wait: ${formatH(offDutyDelay)} from ${formatTime(waitStart)} to ${formatTime(currentTime)}.`);
      }

      remainingDrive -= plannedDrive;

      let driveDetails = isSingle
        ? (plannedDrive > 4.5
            ? `Drive ${formatH(4.5)}, 45m break, then drive ${formatH(plannedDrive - 4.5)}`
            : `Drive ${formatH(plannedDrive)}`)
        : `Drive ${plannedDrive.toFixed(2)}h`;

      const extras = [];
      if (inShiftBreak > 0) extras.push(`in-shift break ${formatH(inShiftBreak)}`);
      if (countedDelay > 0) extras.push(`on-duty delay ${formatH(countedDelay)}${delayNotes.length ? ` (${delayNotes.join(", ")})` : ""}`);
      if (offDutyDelay > 0) extras.push(`off-duty delay ${formatH(offDutyDelay)}${delayNotes.length ? ` (${delayNotes.join(", ")})` : ""}`);

      breakdown.push(
        `Segment ${segmentIndex}:\nStart at ${formatTime(segmentStart)}.\n` +
        `${driveDetails}, covering ${distanceCovered.toFixed(2)} km\n` +
        (extras.length ? `(${extras.join("; ")})\n` : "") +
        `${remainingDrive > 0 ? "End work at" : "End at"} ${formatTime(currentTime)}.`
      );

      segments.push({
        segmentIndex,
        startTime: new Date(segmentStart),
        driveTime: plannedDrive,
        delayOnDuty: countedDelay,
        delayOffDuty: offDutyDelay,
        inShiftBreak,
        endTime: new Date(currentTime)
      });

      // Auto ferry rest handling
      if (remainingDrive > 0 && ferryAsRest) {
        const restLen = pickDailyRest();
        const rs = new Date(currentTime);
        const re = new Date(currentTime.getTime() + restLen * 3600000);
        breakdown.push(`Daily rest (ferry as rest): ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
        currentTime = re;
        dutyUsed = 0;
        continue;
      }

      // Need a daily rest between days if still driving remains
      if (remainingDrive > 0) {
        const restLen = pickDailyRest();
        const rs = new Date(currentTime);
        const re = new Date(currentTime.getTime() + restLen * 3600000);
        breakdown.push(`Daily rest: ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
        currentTime = re;
        dutyUsed = 0;
      }
    }

    if (warnings.length) {
      breakdown.push("Warnings:\n- " + warnings.join("\n- "));
    }

    return { breakdown, finalTime: new Date(currentTime) };
  }

  // ====== CONTROLLER ======
  function calculateTripAndDisplay() {
    const t = translations[currentLang];

    if (!startTimeObj) {
      alert("Please select a start time.");
      return;
    }
    let startTime = new Date(startTimeObj.getTime());

    let driverType = document.querySelector('input[name="driverType"]:checked').value;
    let defaultAvailableTime = (driverType === "single" ? 9 : 18);
    let customTime = parseFloat(document.getElementById('customHours').value);
    let firstSegmentAvailableTime = (!isNaN(customTime) && customTime > 0 && customTime < defaultAvailableTime)
      ? customTime : defaultAvailableTime;

    let distance = parseFloat(document.getElementById('distance').value);
    let speed = parseFloat(document.getElementById('speed').value);
    if (isNaN(distance) || distance <= 0 || isNaN(speed) || speed <= 0) {
      alert("Please enter valid values for distance and speed.");
      return;
    }

    let baseDrivingTime = distance / speed;

    // read UI options
    APP_STATE.settings.autoFerryRest = document.getElementById('autoFerryRestToggle').checked;

    // build refuel events
    let refuelEvents = [];
    let refuelCount = parseInt(document.getElementById('refuels').value) || 0;
    if (refuelCount > 0) {
      let refuelInputs = document.querySelectorAll('.refuelAssignment');
      refuelInputs.forEach(function(input) {
        let seg = parseInt(input.value);
        if (!seg || seg < 1) seg = 1;
        refuelEvents.push({ segment: seg, delay: 1.0 });
      });
    }

    // ferry event
    let ferryTimeMinutes = parseFloat(document.getElementById('ferryTime').value) || 0;
    let ferryDelay = ferryTimeMinutes / 60;
    let ferrySegment = 1;
    if (ferryDelay > 0) {
      ferrySegment = parseInt(document.getElementById('ferrySegment').value);
      if (!ferrySegment || ferrySegment < 1) ferrySegment = 1;
    }
    let ferryEvent = { segment: ferrySegment, delay: ferryDelay };

    const breakOverrides = parseBreakOverrides(document.getElementById('breakOverrides').value);
    const reducedRestIndices = parseReducedRests(document.getElementById('reducedRests').value);

    // run calc
    let out = calculateTripWithDelays(
      APP_STATE,
      baseDrivingTime,
      defaultAvailableTime,
      firstSegmentAvailableTime,
      driverType,
      speed,
      startTime,
      refuelEvents,
      ferryEvent,
      breakOverrides,
      reducedRestIndices
    );

    let totalTripHours = (out.finalTime - startTime) / 3600000;

    // render
    let resultHtml = "<strong>" + t["finalEstimatedArrival"] + "</strong> " + formatDateTime(out.finalTime) +
                     "\n<strong>" + t["totalTripDuration"] + "</strong> " + totalTripHours.toFixed(2) + "h" +
                     "\n\n<strong>" + t["tripBreakdown"] + "</strong>\n<div class='breakdown'>";
    out.breakdown.forEach(function(step) { resultHtml += step + "\n\n"; });
    resultHtml += t["destinationReached"] + " " + formatDateTime(out.finalTime) + "</div>";

    document.getElementById("result").innerHTML = resultHtml;

    // expand accordion
    var collapseElement = document.getElementById('collapseBreakdown');
    var bsCollapse = bootstrap.Collapse.getInstance(collapseElement);
    if (!bsCollapse) { bsCollapse = new bootstrap.Collapse(collapseElement, {toggle: false}); }
    bsCollapse.show();
  }
</script>

<script>
function convertCSV() {
  const input = document.getElementById('csvInput');
  if (!input || !input.files.length) {
    alert("Please select a CSV file.");
    return;
  }
  const file = input.files[0];
  const reader = new FileReader();
  reader.onload = function (e) {
    const lines = e.target.result.split(/\r?\n/).filter(line => line.trim());
    if (lines.length < 2) {
      alert("File is empty or doesn't have enough data.");
      return;
    }
    const outputHeaders = [
      "First Name", "Middle Name", "Last Name",
      "Phonetic First Name", "Phonetic Middle Name", "Phonetic Last Name",
      "Name Prefix", "Name Suffix", "Nickname", "File As",
      "Organization Name", "Organization Title", "Organization Department",
      "Birthday", "Notes", "Photo", "Labels",
      "Phone 1 - Label", "Phone 1 - Value"
    ];
    let outputRows = [outputHeaders.join(",")];
    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(/,(?=(?:(?:[^\"]*\"){2})[^\"]*$)/);
      const name = parts[0]?.replace(/^\"|\"$/g, '') || '';
      const phone = parts[2]?.trim() || '';
      let row = Array(19).fill('');
      row[0] = name;
      row[18] = phone;
      outputRows.push(row.join(','));
    }
    const csvContent = outputRows.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const downloadLink = document.getElementById('download');
    downloadLink.href = url;
    downloadLink.style.display = 'inline-block';
  };
  reader.readAsText(file);
}
</script>

<script>
function parseTruckTrailer(str) {
  // Capture a bracketed tag like [BW/P], [BW/PV], [BW/EK], etc.
  // General format: [PREFIX/CODE] where PREFIX is letters and CODE is 1-3 letters.
  let bwTag = null;
  const tagMatch = str.match(/\[([A-Z]+)\/([A-Z]{1,3})\]/i);
  if (tagMatch) {
    bwTag = `${tagMatch[1].toUpperCase()}/${tagMatch[2].toUpperCase()}`;
  }

  // Remove all bracketed [X/YY] tokens before parsing the rest
  str = str.replace(/\[[A-Z]+\/[A-Z]{1,3}\]/gi, "").trim();

  // Detect driver count (default = 2, but if "1v" is found => 1)
  let drivers = 2;
  if (/1v/i.test(str)) drivers = 1;

  // Split on the first slash to separate truck vs. trailer
  let [left, right = ""] = str.split("/", 2);
  left = left.trim();
  right = right.trim();

  // Extract the first alphanumeric chunk in each side
  const truckMatch = left.match(/[A-Z0-9]+/i);
  const trailerMatch = right.match(/[A-Z0-9]+/i);
  const truck = truckMatch ? truckMatch[0] : left;
  const trailer = trailerMatch ? trailerMatch[0] : right;

  return { truck, trailer, drivers, bwTag };
}
function parseCommaFloat(val) {
  if (!val || val.toString().trim() === "") return null;
  const num = parseFloat(val.toString().replace(",", "."));
  return isNaN(num) ? null : num;
}
function mergeByTruck(rows) {
  const byTruck = {};

  for (let r of rows) {
    const truck = r.Truck;
    if (!byTruck[truck]) {
      byTruck[truck] = r;
    } else {
      const existing = byTruck[truck];

      const newHasW7 = r["Week 7"] != null;
      const oldHasW7 = existing["Week 7"] != null;

      // Helper: preserve BW Tag on the main record
      const ensureBWTag = (keeper, donor) => {
        if ((keeper["BW Tag"] == null || keeper["BW Tag"] === "") && donor["BW Tag"]) {
          keeper["BW Tag"] = donor["BW Tag"];
        }
      };

      if (newHasW7 && !oldHasW7) {
        if (r["Week 6"] == null && existing["Week 6"] != null) {
          r["Week 6"] = existing["Week 6"];
        }
        ensureBWTag(r, existing);
        byTruck[truck] = r;
      } else if (oldHasW7 && !newHasW7) {
        if (existing["Week 6"] == null && r["Week 6"] != null) {
          existing["Week 6"] = r["Week 6"];
        }
        ensureBWTag(existing, r);
      } else if (oldHasW7 && newHasW7) {
        if (r["Week 6"] == null && existing["Week 6"] != null) {
          r["Week 6"] = existing["Week 6"];
        }
        ensureBWTag(r, existing);
        byTruck[truck] = r;
      } else {
        if (existing["Week 6"] == null && r["Week 6"] != null) {
          existing["Week 6"] = r["Week 6"];
        }
        ensureBWTag(existing, r);
      }
    }
  }

  return Object.values(byTruck);
}
function transformData(dataAoA) {
  const rows = [];
  for (let i = 2; i < dataAoA.length; i++) {
    const row = dataAoA[i];
    if (!row || !row.length) break;
    if (!row[0] || /^total$/i.test(row[0].toString().trim())) {
      break;
    }
    const rawTruckTrailer = row[0].toString().trim();
    const week6Val = parseCommaFloat(row[1]);
    const week7Val = parseCommaFloat(row[2]);
    const { truck, trailer, drivers, bwTag } = parseTruckTrailer(rawTruckTrailer);
    rows.push({
      Truck: truck,
      Trailer: trailer,
      "BW Tag": bwTag || "",
      "Week 6": week6Val,
      "Week 7": week7Val,
      Drivers: drivers
    });
  }
  const merged = mergeByTruck(rows);
  let sum6 = 0, sum7 = 0;
  let count6 = 0, count7 = 0;
  merged.forEach(r => {
    if (r["Week 6"] != null) { sum6 += r["Week 6"]; count6++; }
    if (r["Week 7"] != null) { sum7 += r["Week 7"]; count7++; }
  });
  const avg6 = count6 > 0 ? Math.round(sum6 / count6) : "";
  const avg7 = count7 > 0 ? Math.round(sum7 / count7) : "";
  const total6 = count6 > 0 ? Math.round(sum6) : "";
  const total7 = count7 > 0 ? Math.round(sum7) : "";
  merged.push({
    Truck: "",
    Trailer: "Total Average:",
    "BW Tag": "",
    "Week 6": avg6,
    "Week 7": avg7,
    Drivers: ""
  });
  merged.push({
    Truck: "",
    Trailer: "Total Amount:",
    "BW Tag": "",
    "Week 6": total6,
    "Week 7": total7,
    Drivers: ""
  });
  return merged;
}
function createStyledSheet(data) {
  const aoa = [["Truck", "Trailer", "BW Tag", "Week 6", "Week 7", "Drivers"]];
  data.forEach(row => {
    aoa.push([
      row.Truck,
      row.Trailer,
      row["BW Tag"] == null ? "" : row["BW Tag"],
      row["Week 6"] == null ? "" : row["Week 6"],
      row["Week 7"] == null ? "" : row["Week 7"],
      row.Drivers == null ? "" : row.Drivers
    ]);
  });
  const ws = XLSX.utils.aoa_to_sheet(aoa);
  ws['!cols'] = [
    { wch: 10 }, { wch: 12 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 8 }
  ];
  const headerCells = ["A1", "B1", "C1", "D1", "E1", "F1"];
  headerCells.forEach(cellAddr => {
    if (ws[cellAddr]) {
      ws[cellAddr].s = {
        font: { bold: true },
        fill: { fgColor: { rgb: "D9D9D9" } },
        alignment: { horizontal: "center" }
      };
    }
  });
  const totalAvgRowIndex = aoa.length - 2;
  const totalAmtRowIndex = aoa.length - 1;
  [totalAvgRowIndex, totalAmtRowIndex].forEach(rowIndex => {
    for (let col = 0; col < 6; col++) {
      const addr = XLSX.utils.encode_cell({ r: rowIndex, c: col });
      if (!ws[addr]) continue;
      ws[addr].s = ws[addr].s || {};
      ws[addr].s.font = ws[addr].s.font || {};
      ws[addr].s.font.bold = true;
    }
  });
  return ws;
}
function processFile() {
  const fileInput = document.getElementById('inputFile');
  if (!fileInput.files.length) {
    alert("Please select an Excel file.");
    return;
  }
  const file = fileInput.files[0];
  const reader = new FileReader();
  reader.onload = function(e) {
    const dataArray = new Uint8Array(e.target.result);
    const workbook = XLSX.read(dataArray, { type: 'array' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const dataAoA = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
    const finalData = transformData(dataAoA);
    const newWorksheet = createStyledSheet(finalData);
    const newWorkbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(newWorkbook, newWorksheet, "Cleaned Data");
    XLSX.writeFile(newWorkbook, "cleaned_data.xlsx");
  };
  reader.readAsArrayBuffer(file);
}
</script>

<script>
function showSection(id) {
  document.querySelectorAll('.app-section').forEach(sec => sec.style.display = 'none');
  const el = document.getElementById(id);
  if (el) el.style.display = 'block';
}
document.addEventListener('DOMContentLoaded', function() {
  showSection('etaSection');
});
</script>
</body>
</html>
