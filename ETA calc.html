<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Truck ETA Calculator v1.1</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Flatpickr CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    body { background-color: #f4f4f4; }
    .calculator {
      background: #fff; padding: 20px; border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-top: 20px;
    }
    #result { white-space: pre-line; }
    .floating-lang-btn {
      position: fixed; top: 15%; left: 0; z-index: 1050;
    }
    .badge-dot {
      display:inline-block; width:10px; height:10px; border-radius:50%;
      margin-right:6px; background:#0d6efd;
    }
  </style>
</head>
<body>

<!-- Floating Language Selector Button -->
<button class="btn btn-secondary btn-sm floating-lang-btn" data-bs-toggle="offcanvas" data-bs-target="#offcanvasLanguage" aria-controls="offcanvasLanguage">
  US
</button>

<!-- Offcanvas Sidebar for Language Selection -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasLanguage" aria-labelledby="offcanvasLabel">
  <div class="offcanvas-header">
    <h5 id="offcanvasLabel">Select Language</h5>
    <button type="button" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="offcanvas-body">
    <select id="languageSelect" class="form-select" onchange="updateLocalization()">
      <option value="en">English</option>
      <option value="lt">Lietuvių</option>
      <option value="ru">Русский</option>
    </select>
  </div>
</div>

<div class="container">
  <div class="calculator">
    <div class="d-flex align-items-center justify-content-between">
      <h2 id="calcTitle" class="mb-4">Truck ETA Calculator v1.1 (Interactive Delay Adjustment)</h2>
      <span class="text-muted">v1.1</span>
    </div>

    <!-- Controls row -->
    <div class="row g-3">
      <div class="col-md-4">
        <label for="startTime" class="form-label" id="startTimeLabel">Start Time:</label>
        <input type="text" id="startTime" class="form-control">
      </div>

      <div class="col-md-4">
        <p id="drivingConfigLabel" class="fw-bold mb-1">Driving Configuration:</p>
        <div class="form-check">
          <input type="radio" class="form-check-input" id="single" name="driverType" value="single" checked>
          <label for="single" class="form-check-label" id="singleDriverLabel">Single Driver (9h available per segment)</label>
        </div>
        <div class="form-check">
          <input type="radio" class="form-check-input" id="two" name="driverType" value="two">
          <label for="two" class="form-check-label" id="twoDriversLabel">Two Drivers (18h available per segment)</label>
        </div>
      </div>

      <div class="col-md-4">
        <label for="customHours" class="form-label" id="customHoursLabel">Custom remaining driving time for first segment (optional):</label>
        <input type="number" id="customHours" placeholder="e.g., 6" step="0.1" class="form-control">
      </div>

      <div class="col-md-4">
        <label for="distance" class="form-label" id="distanceLabel">Distance to Drive (km):</label>
        <input type="number" id="distance" step="0.1" class="form-control">
      </div>

      <div class="col-md-4">
        <label for="speed" class="form-label" id="speedLabel">Average Speed (km/h):</label>
        <input type="number" id="speed" step="0.1" class="form-control">
      </div>

      <!-- Refuelings input -->
      <div class="col-md-4">
        <label for="refuels" class="form-label" id="refuelsLabel">Number of Refuelings (each 1h delay):</label>
        <input type="number" id="refuels" min="0" max="10" value="0" class="form-control">
      </div>

      <!-- Ferry time -->
      <div class="col-md-4">
        <label for="ferryTime" class="form-label" id="ferryTimeLabel">Total Ferry Time (minutes delay):</label>
        <input type="number" id="ferryTime" min="0" value="0" class="form-control">
      </div>

      <!-- Options -->
      <div class="col-md-8">
        <div class="card">
          <div class="card-body">
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="autoFerryRestToggle" checked>
              <label class="form-check-label" for="autoFerryRestToggle" id="autoFerryRestLabel">
                Auto-convert any ferry ≥ 6h into a daily rest
              </label>
            </div>
            <div class="small text-muted" id="dutyRuleNote">
              Delays are off-duty by default; they will count inside duty as needed to keep daily spread ≤ 15h (single) or 21h (two).
            </div>
            <div class="mt-2">
              <span class="badge-dot"></span>
              <span id="reducedRestsInfo">Reduced (9h) daily rests used this week: <strong id="reducedCount">0</strong>/2</span>
              <button id="resetWeekBtn" class="btn btn-sm btn-outline-secondary ms-2">Reset week counter</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Ferry assignment container (shown only if ferry > 0) -->
      <div class="col-12" id="ferryAssignmentContainer" style="display:none;">
        <div class="card mt-2">
          <div class="card-body">
            <h5 id="ferryDelayAssignmentHeader" class="mb-3">Ferry Delay Assignment</h5>
            <label for="ferrySegment" class="form-label" id="ferrySegmentLabel">Apply Ferry Delay in segment (number):</label>
            <input type="number" id="ferrySegment" min="1" value="1" class="form-control" style="max-width:200px;">
          </div>
        </div>
      </div>

      <!-- Refuel assignment container -->
      <div class="col-12">
        <div class="card mt-2">
          <div class="card-body">
            <div id="refuelAssignmentsContainer"></div>
          </div>
        </div>
      </div>

    </div><!-- /row -->

    <!-- Calculate button -->
    <div class="mt-4">
      <button id="calcTripButton" onclick="calculateTripAndDisplay()" class="btn btn-primary">Calculate Trip</button>
    </div>

    <!-- Trip Breakdown & Results -->
    <div class="accordion mt-4" id="tripBreakdownAccordion">
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingBreakdown">
          <button id="tripBreakdownAccordionButton" class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseBreakdown" aria-expanded="false" aria-controls="collapseBreakdown">
            Trip Breakdown & Results
          </button>
        </h2>
        <div id="collapseBreakdown" class="accordion-collapse collapse" aria-labelledby="headingBreakdown" data-bs-parent="#tripBreakdownAccordion">
          <div class="accordion-body" id="result"><!-- results injected here --></div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- Bootstrap Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<!-- Flatpickr -->
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script>
  // ====== SETTINGS (v1.1) ======
  const SETTINGS = {
    dutyCapHours: { single: 15, two: 21 },   // daily spread caps
    delayMode: "auto",                       // off-duty by default; pull in as needed
    autoFerryRest: true,                     // default ON (toggle in UI)
    autoFerryRestThreshold: 6,               // hours
    preferReducedRestFirst: true             // prefer 9h before 11h
  };
  // Weekly counter for 9h reduced daily rests (reset with button)
  let WEEKLY_9H_RESTS_USED = 0;

  // ====== I18N ======
  var translations = {
    "en": {
      "title": "Truck ETA Calculator v1.1 (Interactive Delay Adjustment)",
      "drivingConfiguration": "Driving Configuration:",
      "singleDriver": "Single Driver (9h available per segment)",
      "twoDrivers": "Two Drivers (18h available per segment)",
      "customHours": "Custom remaining driving time for first segment (optional):",
      "distance": "Distance to Drive (km):",
      "speed": "Average Speed (km/h):",
      "refuels": "Number of Refuelings (each 1h delay):",
      "ferryTime": "Total Ferry Time (minutes delay):",
      "calculateTrip": "Calculate Trip",
      "ferryDelayAssignment": "Ferry Delay Assignment",
      "applyFerryDelayInSegment": "Apply Ferry Delay in segment (number):",
      "tripBreakdownResults": "Trip Breakdown & Results",
      "finalEstimatedArrival": "Final Estimated Arrival Time (with delays):",
      "totalTripDuration": "Total Trip Duration (with delays):",
      "tripBreakdown": "Trip Breakdown:",
      "destinationReached": "Arrival:",
      "autoFerryRestLabel": "Auto-convert any ferry ≥ 6h into a daily rest",
      "dutyRuleNote": "Delays are off-duty by default; they will count inside duty as needed to keep daily spread ≤ 15h (single) or 21h (two).",
      "reducedInfo": "Reduced (9h) daily rests used this week:",
      "noRefuels": "No refuel delays specified."
    },
    "lt": {
      "title": "Sunkvežimio atvykimo laiko skaičiuoklė v1.1 (interaktyvus vėlavimų koregavimas)",
      "drivingConfiguration": "Vairavimo konfigūracija:",
      "singleDriver": "Vairuotojas vienas (9 val. per segmentą)",
      "twoDrivers": "Du vairuotojai (18 val. per segmentą)",
      "customHours": "Pirmojo segmento likęs vairavimo laikas (nebūtina):",
      "distance": "Važiavimo atstumas (km):",
      "speed": "Vidutinis greitis (km/h):",
      "refuels": "Degalų papildymų skaičius (kiekvienas – 1 val. vėlavimas):",
      "ferryTime": "Kelto laikas (vėlavimas min.):",
      "calculateTrip": "Apskaičiuoti kelionę",
      "ferryDelayAssignment": "Kelto vėlavimo priskyrimas",
      "applyFerryDelayInSegment": "Priskirti kelto laiką segmentui (numeris):",
      "tripBreakdownResults": "Kelionės apžvalga ir rezultatai",
      "finalEstimatedArrival": "Numatomas atvykimo laikas (su vėlavimais):",
      "totalTripDuration": "Bendra kelionės trukmė (su vėlavimais):",
      "tripBreakdown": "Kelionės apžvalga:",
      "destinationReached": "Atvykimas:",
      "autoFerryRestLabel": "Automatiškai paversti ≥ 6 val. keltą dienos poilsiu",
      "dutyRuleNote": "Vėlavimai pagal nutylėjimą neskaičiuojami kaip darbo laikas; prireikus bus įtraukti, kad dienos trukmė neviršytų 15 val. (vienas) ar 21 val. (du).",
      "reducedInfo": "Sumažintų (9 val.) dienos poilsių šią savaitę:",
      "noRefuels": "Degalų papildymų nenurodyta."
    },
    "ru": {
      "title": "Калькулятор ETA грузовика v1.1 (интерактивная корректировка задержек)",
      "drivingConfiguration": "Конфигурация вождения:",
      "singleDriver": "Один водитель (9 ч на сегмент)",
      "twoDrivers": "Два водителя (18 ч на сегмент)",
      "customHours": "Оставшееся время вождения для первого сегмента (необязательно):",
      "distance": "Расстояние (км):",
      "speed": "Средняя скорость (км/ч):",
      "refuels": "Количество заправок (каждая — задержка 1 ч):",
      "ferryTime": "Время парома (задержка, мин):",
      "calculateTrip": "Рассчитать поездку",
      "ferryDelayAssignment": "Назначение задержки парома",
      "applyFerryDelayInSegment": "Применить задержку парома к сегменту (номер):",
      "tripBreakdownResults": "Разбивка поездки и результаты",
      "finalEstimatedArrival": "Предполагаемое время прибытия (с задержками):",
      "totalTripDuration": "Общая длительность поездки (с задержками):",
      "tripBreakdown": "Разбивка поездки:",
      "destinationReached": "Прибытие:",
      "autoFerryRestLabel": "Автоматически превращать паром ≥ 6 ч в ежедневный отдых",
      "dutyRuleNote": "Задержки по умолчанию вне рабочего времени; при необходимости будут учтены как рабочее, чтобы держать пределы 15 ч (один) / 21 ч (два).",
      "reducedInfo": "Сокращённые (9 ч) ежедневные отдыхи на этой неделе:",
      "noRefuels": "Заправки не указаны."
    }
  };
  var currentLang = "en";

  // ====== GLOBALS ======
  let startTimeObj = null; // Safari-safe: captured from Flatpickr onChange

  // ====== UTILITIES ======
  function formatTime(date) {
    let h = date.getHours();
    let m = date.getMinutes();
    if (h < 10) h = '0' + h;
    if (m < 10) m = '0' + m;
    return h + ':' + m;
  }
  function formatDateTime(date) {
    const y = date.getFullYear();
    let mo = date.getMonth() + 1, d = date.getDate();
    if (mo < 10) mo = '0' + mo;
    if (d < 10) d = '0' + d;
    return y + '-' + mo + '-' + d + ' ' + formatTime(date);
  }
  function formatH(h) {
    const total = Math.round(h * 60);
    const hh = Math.floor(total / 60);
    const mm = total % 60;
    return `${hh}h ${mm.toString().padStart(2, "0")}m`;
  }

  // ====== INIT PICKER (Safari-safe) ======
  flatpickr("#startTime", {
    enableTime: true,
    dateFormat: "Y-m-d H:i",
    time_24hr: true,
    onChange: (selectedDates) => { startTimeObj = selectedDates[0] || null; }
  });

  // ====== I18N APPLY ======
  function updateLocalization() {
    currentLang = document.getElementById("languageSelect").value;
    const t = translations[currentLang];

    document.getElementById("calcTitle").innerText = t["title"];
    document.getElementById("drivingConfigLabel").innerText = t["drivingConfiguration"];
    document.getElementById("singleDriverLabel").innerText = t["singleDriver"];
    document.getElementById("twoDriversLabel").innerText = t["twoDrivers"];
    document.getElementById("customHoursLabel").innerText = t["customHours"];
    document.getElementById("distanceLabel").innerText = t["distance"];
    document.getElementById("speedLabel").innerText = t["speed"];
    document.getElementById("refuelsLabel").innerText = t["refuels"];
    document.getElementById("ferryTimeLabel").innerText = t["ferryTime"];
    document.getElementById("calcTripButton").innerText = t["calculateTrip"];
    document.getElementById("ferryDelayAssignmentHeader").innerText = t["ferryDelayAssignment"];
    document.getElementById("ferrySegmentLabel").innerText = t["applyFerryDelayInSegment"];
    document.getElementById("tripBreakdownAccordionButton").innerText = t["tripBreakdownResults"];
    document.getElementById("autoFerryRestLabel").innerText = t["autoFerryRestLabel"];
    document.getElementById("dutyRuleNote").innerText = t["dutyRuleNote"];
    document.getElementById("reducedRestsInfo").innerHTML =
      `${t["reducedInfo"]} <strong id="reducedCount">${WEEKLY_9H_RESTS_USED}</strong>/2`;

    // Floating button text
    var langButton = document.querySelector(".floating-lang-btn");
    langButton.textContent = currentLang === "en" ? "US" : (currentLang === "lt" ? "LT" : "RU");

    // regenerate refuel assignment text
    generateRefuelAssignments();
  }

  // ====== EVENT WIRING ======
  window.onload = function() {
    updateLocalization();
    updateFerryAssignmentVisibility();
    document.getElementById('reducedCount').innerText = WEEKLY_9H_RESTS_USED;
    document.getElementById('autoFerryRestToggle').checked = SETTINGS.autoFerryRest;
  };

  document.getElementById('ferryTime').addEventListener('input', updateFerryAssignmentVisibility);
  document.getElementById('refuels').addEventListener('input', function() {
    let v = parseInt(this.value) || 0; if (v > 10) this.value = 10;
    generateRefuelAssignments();
  });

  document.querySelectorAll('input[name="driverType"]').forEach(r => {
    r.addEventListener('change', () => {/* nothing extra needed; calculation uses it directly */});
  });

  document.getElementById('distance').addEventListener('input', ()=>{});
  document.getElementById('speed').addEventListener('input', ()=>{});
  document.getElementById('customHours').addEventListener('input', ()=>{});

  document.getElementById('resetWeekBtn').addEventListener('click', () => {
    WEEKLY_9H_RESTS_USED = 0;
    document.getElementById('reducedCount').innerText = WEEKLY_9H_RESTS_USED;
    updateLocalization();
  });

  document.getElementById('autoFerryRestToggle').addEventListener('change', (e) => {
    SETTINGS.autoFerryRest = e.target.checked;
  });

  // ====== UI HELPERS ======
  function updateFerryAssignmentVisibility() {
    var ferryTimeValue = parseFloat(document.getElementById('ferryTime').value) || 0;
    var c = document.getElementById('ferryAssignmentContainer');
    c.style.display = ferryTimeValue > 0 ? "block" : "none";
  }

  function generateRefuelAssignments() {
    const t = translations[currentLang];
    let refuelCount = parseInt(document.getElementById('refuels').value) || 0;
    let container = document.getElementById('refuelAssignmentsContainer');
    container.innerHTML = "";
    if (refuelCount > 0) {
      container.innerHTML += `<h5>${t["refuelDelayAssignments"] || "Refuel Delay Assignments"}</h5>`;
      for (let i = 0; i < refuelCount; i++) {
        const row = document.createElement('div');
        row.className = 'd-flex align-items-center mb-2';
        row.innerHTML = `
          <div class="me-2">${(t["refuelEvent"] || "Refuel event ")}${i+1}${(t["segment"] || " segment: ")}</div>
          <input type="number" class="refuelAssignment form-control" min="1" value="1" style="max-width:120px;">
        `;
        container.appendChild(row);
      }
    } else {
      container.innerHTML = `<p class="mb-0">${t["noRefuels"]}</p>`;
    }
  }

  // ====== CORE CALC (v1.1) ======
  function calculateTripWithDelays(
    baseTime,                    // hours to drive (distance / speed)
    defaultAvailableTime,        // 9 or 18
    firstSegmentAvailableTime,
    driverType,                  // "single" | "two"
    speed,                       // km/h
    startTime,                   // Date
    refuelEvents,                // [{segment, delay:1.0}, ...]
    ferryEvent                   // {segment, delay:hours}
  ) {
    const breakdown = [];
    const segments = [];

    const isSingle = (driverType === "single");
    const dutyCap = isSingle ? SETTINGS.dutyCapHours.single : SETTINGS.dutyCapHours.two;

    let currentTime = new Date(startTime.getTime());
    let remainingDrive = baseTime;
    let segmentIndex = 0;

    // Duty since last DAILY REST
    let dutyUsed = 0;

    // Warnings
    let warnings = [];

    function pickDailyRest() {
      if (isSingle && SETTINGS.preferReducedRestFirst && WEEKLY_9H_RESTS_USED < 2) {
        WEEKLY_9H_RESTS_USED++;
        const reducedEl = document.getElementById('reducedCount');
        if (reducedEl) reducedEl.innerText = WEEKLY_9H_RESTS_USED;
        if (WEEKLY_9H_RESTS_USED > 2) {
          warnings.push("More than two 9h reduced daily rests used this week.");
        }
        return 9;
      }
      return 11;
    }

    function getDelaysForSegment(segIdx) {
      let extraDelay = 0;
      let delayNotes = [];

      if (refuelEvents && refuelEvents.length) {
        refuelEvents.forEach(e => {
          if (e.segment === segIdx) {
            extraDelay += e.delay;
            delayNotes.push(`refuel ${e.delay.toFixed(2)}h`);
          }
        });
      }

      let ferryDelay = 0, ferryNote = "";
      let ferryAsRest = false;
      if (ferryEvent && ferryEvent.delay > 0 && ferryEvent.segment === segIdx) {
        ferryDelay = ferryEvent.delay;
        ferryNote = `ferry ${ferryDelay.toFixed(2)}h`;
        if (SETTINGS.autoFerryRest && ferryDelay >= SETTINGS.autoFerryRestThreshold) {
          ferryAsRest = true;
        }
      }
      extraDelay += ferryDelay;
      if (ferryNote) delayNotes.push(ferryNote);

      return { extraDelay, delayNotes, ferryAsRest, ferryDelay };
    }

    while (remainingDrive > 0) {
      segmentIndex++;
      const segmentAvail = (segmentIndex === 1 ? firstSegmentAvailableTime : defaultAvailableTime);

      const { extraDelay, delayNotes, ferryAsRest } = getDelaysForSegment(segmentIndex);

      let plannedDrive = Math.min(segmentAvail, remainingDrive);
      let inShiftBreak = 0;
      if (isSingle && plannedDrive > 4.5) inShiftBreak = 0.75;

      // AUTO delay behavior
      let countedDelay = extraDelay;
      let offDutyDelay = 0;

      if (SETTINGS.delayMode === "auto" && !ferryAsRest) {
        countedDelay = 0; // try keeping all delay off-duty
        let wouldBe = dutyUsed + plannedDrive + inShiftBreak;
        if (wouldBe > dutyCap) {
          // Trim driving to respect cap
          const overflow = wouldBe - dutyCap;
          plannedDrive = Math.max(0, plannedDrive - overflow);
          inShiftBreak = (isSingle && plannedDrive > 4.5) ? 0.75 : (plannedDrive > 0 ? 0 : 0);
        } else {
          // Pull just enough delay into duty, rest off-duty
          const room = dutyCap - (dutyUsed + plannedDrive + inShiftBreak);
          countedDelay = Math.min(extraDelay, room);
          offDutyDelay = extraDelay - countedDelay;
        }
      }

      // Two drivers: ensure we never exceed per-segment available after counted delay
      if (!isSingle) {
        const effectiveAvail = Math.max(0, segmentAvail - countedDelay);
        plannedDrive = Math.min(plannedDrive, effectiveAvail, remainingDrive);
      }

      const segmentDuty = plannedDrive + inShiftBreak + countedDelay;

      // Delay-only segment (no driving)
      if (plannedDrive === 0 && (countedDelay > 0 || offDutyDelay > 0)) {
        const startAt = new Date(currentTime);
        if (countedDelay > 0) {
          dutyUsed += countedDelay;
          currentTime = new Date(currentTime.getTime() + countedDelay * 3600000);
        }
        if (offDutyDelay > 0) {
          currentTime = new Date(currentTime.getTime() + offDutyDelay * 3600000);
        }
        const delayText = delayNotes.length ? ` (Extra: ${delayNotes.join(", ")})` : "";
        breakdown.push(
          `Segment ${segmentIndex}:\nStart at ${formatTime(startAt)}.\nDelay-only${delayText}\nEnd at ${formatTime(currentTime)}.`
        );
        if (ferryAsRest) {
          const restLen = pickDailyRest();
          const rs = new Date(currentTime);
          const re = new Date(currentTime.getTime() + restLen * 3600000);
          breakdown.push(`Daily rest (ferry as rest): ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
          currentTime = re;
          dutyUsed = 0;
        }
        continue;
      }

      // Normal driving segment
      const segmentStart = new Date(currentTime);
      const distanceCovered = plannedDrive * speed;

      // Advance time for driving + in-shift + counted delay
      currentTime = new Date(currentTime.getTime() + segmentDuty * 3600000);
      dutyUsed += plannedDrive + inShiftBreak + countedDelay;

      if (offDutyDelay > 0) {
        const waitStart = new Date(currentTime);
        currentTime = new Date(currentTime.getTime() + offDutyDelay * 3600000);
        breakdown.push(`Off-duty wait: ${formatH(offDutyDelay)} from ${formatTime(waitStart)} to ${formatTime(currentTime)}.`);
      }

      remainingDrive -= plannedDrive;

      let driveDetails = isSingle
        ? (plannedDrive > 4.5
            ? `Drive ${formatH(4.5)}, 45m break, then drive ${formatH(plannedDrive - 4.5)}`
            : `Drive ${formatH(plannedDrive)}`)
        : `Drive ${plannedDrive.toFixed(2)}h`;

      const extras = [];
      if (inShiftBreak > 0) extras.push(`in-shift break ${formatH(inShiftBreak)}`);
      if (countedDelay > 0) extras.push(`on-duty delay ${formatH(countedDelay)}${delayNotes.length ? ` (${delayNotes.join(", ")})` : ""}`);
      if (offDutyDelay > 0) extras.push(`off-duty delay ${formatH(offDutyDelay)}${delayNotes.length ? ` (${delayNotes.join(", ")})` : ""}`);

      breakdown.push(
        `Segment ${segmentIndex}:\nStart at ${formatTime(segmentStart)}.\n` +
        `${driveDetails}, covering ${distanceCovered.toFixed(2)} km\n` +
        (extras.length ? `(${extras.join("; ")})\n` : "") +
        `${remainingDrive > 0 ? "End work at" : "End at"} ${formatTime(currentTime)}.`
      );

      segments.push({
        segmentIndex,
        startTime: new Date(segmentStart),
        driveTime: plannedDrive,
        delayOnDuty: countedDelay,
        delayOffDuty: offDutyDelay,
        inShiftBreak,
        endTime: new Date(currentTime)
      });

      // Auto ferry rest handling
      if (remainingDrive > 0 && ferryAsRest) {
        const restLen = pickDailyRest();
        const rs = new Date(currentTime);
        const re = new Date(currentTime.getTime() + restLen * 3600000);
        breakdown.push(`Daily rest (ferry as rest): ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
        currentTime = re;
        dutyUsed = 0;
        continue;
      }

      // Need a daily rest between days if still driving remains
      if (remainingDrive > 0) {
        const restLen = pickDailyRest();
        const rs = new Date(currentTime);
        const re = new Date(currentTime.getTime() + restLen * 3600000);
        breakdown.push(`Daily rest: ${formatH(restLen)} from ${formatTime(rs)} to ${formatTime(re)}.`);
        currentTime = re;
        dutyUsed = 0;
      }
    }

    if (warnings.length) {
      breakdown.push("Warnings:\n- " + warnings.join("\n- "));
    }

    return { breakdown, finalTime: new Date(currentTime) };
  }

  // ====== CONTROLLER ======
  function calculateTripAndDisplay() {
    const t = translations[currentLang];

    if (!startTimeObj) {
      alert("Please select a start time.");
      return;
    }
    let startTime = new Date(startTimeObj.getTime());

    let driverType = document.querySelector('input[name="driverType"]:checked').value;
    let defaultAvailableTime = (driverType === "single" ? 9 : 18);
    let customTime = parseFloat(document.getElementById('customHours').value);
    let firstSegmentAvailableTime = (!isNaN(customTime) && customTime > 0 && customTime < defaultAvailableTime)
      ? customTime : defaultAvailableTime;

    let distance = parseFloat(document.getElementById('distance').value);
    let speed = parseFloat(document.getElementById('speed').value);
    if (isNaN(distance) || distance <= 0 || isNaN(speed) || speed <= 0) {
      alert("Please enter valid values for distance and speed.");
      return;
    }

    let baseDrivingTime = distance / speed;

    // read UI options
    SETTINGS.autoFerryRest = document.getElementById('autoFerryRestToggle').checked;

    // build refuel events
    let refuelEvents = [];
    let refuelCount = parseInt(document.getElementById('refuels').value) || 0;
    if (refuelCount > 0) {
      let refuelInputs = document.querySelectorAll('.refuelAssignment');
      refuelInputs.forEach(function(input) {
        let seg = parseInt(input.value);
        if (!seg || seg < 1) seg = 1;
        refuelEvents.push({ segment: seg, delay: 1.0 });
      });
    }

    // ferry event
    let ferryTimeMinutes = parseFloat(document.getElementById('ferryTime').value) || 0;
    let ferryDelay = ferryTimeMinutes / 60;
    let ferrySegment = 1;
    if (ferryDelay > 0) {
      ferrySegment = parseInt(document.getElementById('ferrySegment').value);
      if (!ferrySegment || ferrySegment < 1) ferrySegment = 1;
    }
    let ferryEvent = { segment: ferrySegment, delay: ferryDelay };

    // run calc
    let out = calculateTripWithDelays(
      baseDrivingTime,
      defaultAvailableTime,
      firstSegmentAvailableTime,
      driverType,
      speed,
      startTime,
      refuelEvents,
      ferryEvent
    );

    let totalTripHours = (out.finalTime - startTime) / 3600000;

    // render
    let resultHtml = "<strong>" + t["finalEstimatedArrival"] + "</strong> " + formatDateTime(out.finalTime) +
                     "\n<strong>" + t["totalTripDuration"] + "</strong> " + totalTripHours.toFixed(2) + "h" +
                     "\n\n<strong>" + t["tripBreakdown"] + "</strong>\n<div class='breakdown'>";
    out.breakdown.forEach(function(step) { resultHtml += step + "\n\n"; });
    resultHtml += t["destinationReached"] + " " + formatDateTime(out.finalTime) + "</div>";

    document.getElementById("result").innerHTML = resultHtml;

    // expand accordion
    var collapseElement = document.getElementById('collapseBreakdown');
    var bsCollapse = bootstrap.Collapse.getInstance(collapseElement);
    if (!bsCollapse) { bsCollapse = new bootstrap.Collapse(collapseElement, {toggle: false}); }
    bsCollapse.show();
  }
</script>
</body>
</html>
